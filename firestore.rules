rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Allow read/write access to authenticated users for their own user documents
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // Lobby rules - existing functionality
    match /lobbies/{lobbyId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null && 
        request.auth.uid == resource.data.hostUid;
      allow update: if request.auth != null && (
        // Host can update lobby settings
        request.auth.uid == resource.data.hostUid ||
        // Players can join/leave (update players array)
        (request.auth.uid != resource.data.hostUid && 
         onlyUpdatingPlayersList())
      );
      allow delete: if request.auth != null && 
        request.auth.uid == resource.data.hostUid;
    }

    // Game documents - new for meme battle gameplay
    match /games/{gameId} {
      // Allow read access to all players in the game
      allow read: if request.auth != null && 
        request.auth.uid in resource.data.players.keys();
      
      // Allow create only by authenticated users
      allow create: if request.auth != null && 
        request.auth.uid in request.resource.data.players.keys();
      
      // Allow updates only by players in the game
      allow update: if request.auth != null && 
        request.auth.uid in resource.data.players.keys() &&
        validateGameUpdate();
      
      // Only host can delete game
      allow delete: if request.auth != null && 
        request.auth.uid == resource.data.hostId;
    }

    // Game chat subcollection
    match /games/{gameId}/chat/{messageId} {
      // Allow read to all players in the game
      allow read: if request.auth != null && 
        request.auth.uid in get(/databases/$(database)/documents/games/$(gameId)).data.players.keys();
      
      // Allow create only by the message author
      allow create: if request.auth != null && 
        request.auth.uid == request.resource.data.playerId &&
        request.auth.uid in get(/databases/$(database)/documents/games/$(gameId)).data.players.keys();
      
      // No updates or deletes allowed for chat messages
      allow update, delete: if false;
    }

    // Helper functions
    function onlyUpdatingPlayersList() {
      return request.resource.data.diff(resource.data).affectedKeys().hasOnly(['players', 'updatedAt']);
    }

    function validateGameUpdate() {
      let currentUserId = request.auth.uid;
      let gameData = resource.data;
      let newGameData = request.resource.data;
      
      // Ensure user is a player in the game
      return currentUserId in gameData.players.keys() &&
        // Validate that only allowed fields are being updated
        validateAllowedGameFields() &&
        // Validate game phase transitions
        validateGamePhaseTransition() &&
        // Validate submissions
        validateSubmissions() &&
        // Validate votes
        validateVotes();
    }

    function validateAllowedGameFields() {
      let allowedFields = [
        'phase', 'phaseStartTime', 'currentSituation', 'currentRound',
        'submissions', 'votes', 'players', 'updatedAt', 'chat'
      ];
      return request.resource.data.diff(resource.data).affectedKeys().hasOnly(allowedFields);
    }

    function validateGamePhaseTransition() {
      let currentPhase = resource.data.phase;
      let newPhase = request.resource.data.phase;
      let validTransitions = {
        'loading': ['submission'],
        'submission': ['voting', 'submission'],
        'voting': ['results', 'voting'],
        'results': ['submission', 'game_over'],
        'game_over': ['game_over']
      };
      
      return newPhase == currentPhase || 
        (currentPhase in validTransitions && 
         newPhase in validTransitions[currentPhase]);
    }

    function validateSubmissions() {
      let currentUserId = request.auth.uid;
      let oldSubmissions = resource.data.submissions;
      let newSubmissions = request.resource.data.submissions;
      
      // If submissions didn't change, validation passes
      if (oldSubmissions == newSubmissions) {
        return true;
      }
      
      // User can only add their own submission
      return currentUserId in newSubmissions &&
        !(currentUserId in oldSubmissions) &&
        newSubmissions[currentUserId].keys().hasAll(['memeFilename', 'submittedAt']);
    }

    function validateVotes() {
      let currentUserId = request.auth.uid;
      let oldVotes = resource.data.votes;
      let newVotes = request.resource.data.votes;
      
      // If votes didn't change, validation passes
      if (oldVotes == newVotes) {
        return true;
      }
      
      // User can only add their own vote
      return currentUserId in newVotes &&
        !(currentUserId in oldVotes) &&
        // Cannot vote for their own submission
        !(newVotes[currentUserId] == currentUserId);
    }
  }
}